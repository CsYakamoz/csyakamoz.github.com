<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on CsYakamoz`s Blog</title>
    <link>https://csyakamoz.github.io/post/</link>
    <description>Recent content in Posts on CsYakamoz`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 09 Sep 2020 16:38:46 +0800</lastBuildDate>
    
	<atom:link href="https://csyakamoz.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RabbitMQ 交换机类型</title>
      <link>https://csyakamoz.github.io/post/rabbitmq-exchange-type/</link>
      <pubDate>Wed, 09 Sep 2020 16:38:46 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/rabbitmq-exchange-type/</guid>
      <description>RabbitMQ 的交换机共有四种类型。 fanout - 扇形 direct - 直连 topic - 主题 headers - 头（尚未了解，此文不说明） /** * 发布消息到指定交换机 * @param {string} exchange - 交换机名 * @param {string} routingKey - 该消息的路</description>
    </item>
    
    <item>
      <title>RabbitMQ 笔记</title>
      <link>https://csyakamoz.github.io/post/rabbitmq-note/</link>
      <pubDate>Wed, 09 Sep 2020 16:35:55 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/rabbitmq-note/</guid>
      <description>RabbitMQ 官方教程 名词 生产者 (Producing): 发送消息到交换机 路由键 (Routing Key): 消息属性，由生产者在发送消息时声明 交换机 (Exchange): 接受来自生产者的消息，并将消息分发给满足条件的队列</description>
    </item>
    
    <item>
      <title>Git 笔记</title>
      <link>https://csyakamoz.github.io/post/git-note/</link>
      <pubDate>Wed, 09 Sep 2020 16:29:42 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/git-note/</guid>
      <description>初始化 git config --global user.name &amp;#34;your name&amp;#34; git config --global user.email &amp;#34;yourEmail@example.com&amp;#34; 文件的状态 未跟踪 (untracked) 已跟踪 (tracked) 未修改 (unmodified) 已修改 (modified) 已暂存 (staged) 已提交 (committed) 未修改和已提交本质上是同一种状态 三个工作区域 工作目录 (Working</description>
    </item>
    
    <item>
      <title>Javascript this 的指向</title>
      <link>https://csyakamoz.github.io/post/javascript-this/</link>
      <pubDate>Wed, 09 Sep 2020 16:14:29 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/javascript-this/</guid>
      <description>// Notice: the environment is Node.js global.val = &amp;#34;global&amp;#34;; this.val = &amp;#34;exports&amp;#34;; function normalFun() { console.log(this.val); } const funcExpression = function () { console.log(this.val); }; const arrowFun = () =&amp;gt; { console.log(this.val); }; const scope = { val: &amp;#34;obj&amp;#34;, a: function () { console.log(this.val); }, b: () =&amp;gt; { console.log(this.val); }, c: function () { return () =&amp;gt; { console.log(this.val); }; }, d: function () { return function () {</description>
    </item>
    
    <item>
      <title>forEach With Async Function in Js</title>
      <link>https://csyakamoz.github.io/post/javascript-foreach-with-async-func/</link>
      <pubDate>Wed, 09 Sep 2020 14:05:20 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/javascript-foreach-with-async-func/</guid>
      <description>const sleep = (ms) =&amp;gt; new Promise((resolve) =&amp;gt; setTimeout(() =&amp;gt; resolve(ms), ms * 1000)); 假设我们需要对数组中的三个元素进行异步操作，而且要按顺序。 即，对数组中的元素按顺序调用异步函数（本文为 sleep</description>
    </item>
    
    <item>
      <title>Xor Cipher - 异或加密的应用场景之一</title>
      <link>https://csyakamoz.github.io/post/xor-cipher/</link>
      <pubDate>Wed, 09 Sep 2020 13:24:09 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/xor-cipher/</guid>
      <description>异或加密是一种简单的加密算法。 具体内容请看下列文章： XOR cipher XOR 加密简介 本文只讨论个人所应用到的场景。 需求 在工作中，个人经常遇到使用 UUID 作为各种对象</description>
    </item>
    
    <item>
      <title>Shell 笔记</title>
      <link>https://csyakamoz.github.io/post/shell-note/</link>
      <pubDate>Wed, 09 Sep 2020 11:35:19 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/shell-note/</guid>
      <description>Lint ShellCheck, a static analysis tool for shell scripts 建议使用 ShellCheck, 以检查脚本中潜在的问题 Shebang shebang 即 #! , 其后面跟的是解释当前脚本的解释器路径 e.g. #!/bin/bash #!/usr/bin/bash #!/usr/bin/env bash 个人习惯用 #!/usr/bin/env NAME 而不是 #!/usr/bin/NAME 原因请看此：</description>
    </item>
    
    <item>
      <title>MacOS 修复音视频无法正常播放问题</title>
      <link>https://csyakamoz.github.io/post/mac-fix-sound/</link>
      <pubDate>Wed, 09 Sep 2020 11:32:06 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/mac-fix-sound/</guid>
      <description>内容来源：mac 音频及视频均无法正常播放，怎么解决？ 表现现象： 音乐播放器无法播放，进度条停留在起始点，且为缓冲状态，但网络是正常 BiliBili 也无法播放</description>
    </item>
    
    <item>
      <title>Tmux 笔记</title>
      <link>https://csyakamoz.github.io/post/tmux-note/</link>
      <pubDate>Wed, 09 Sep 2020 11:26:08 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/tmux-note/</guid>
      <description>Tmux with iTerm2 iTerm2 is integrated with tmux, allowing you to enjoy a native user interface with all the benefits of tmux&amp;rsquo;s persistence. MacOS 用户建议使用 iTerm2 的 Tmux 特性 使用方法，请看文档：https://www.iterm2.com/do</description>
    </item>
    
    <item>
      <title>常用软件记录</title>
      <link>https://csyakamoz.github.io/post/software/</link>
      <pubDate>Wed, 09 Sep 2020 11:24:18 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/software/</guid>
      <description>记录个人常用的软件 Application Typora: Typora is a minimal markdown editor, providing new ways for reading and writing markdown. iTerm2: iTerm2 is a replacement for Terminal and the successor to iTerm. Snipaste: Snipaste is a simple but powerful snipping tool, and also allows you to pin the screenshot back onto the screen. Notion: All-in-one workspace. Dash: Dash gives your Mac instant offline access to</description>
    </item>
    
    <item>
      <title>Shell 序列表达式</title>
      <link>https://csyakamoz.github.io/post/shell-sequence-expression/</link>
      <pubDate>Wed, 09 Sep 2020 11:18:01 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/shell-sequence-expression/</guid>
      <description>格式：{FIRST..LAST[..INCREMENT]} FIRST 和 LAST 是必需的，用 .. 分隔，中间没有空格，INCREMENT 是可选滴 Example echo {1..3} # 1 2 3 echo</description>
    </item>
    
    <item>
      <title>Shell 按行处理文本</title>
      <link>https://csyakamoz.github.io/post/shell-handle-text-by-line/</link>
      <pubDate>Wed, 09 Sep 2020 11:15:00 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/shell-handle-text-by-line/</guid>
      <description>内容来源：【Shell 脚本】逐行处理文本文件 read cat data.dat | while read line do echo &amp;#34;${line}&amp;#34; done # or while read line do echo &amp;#34;${line}&amp;#34; done &amp;lt; data.dat awk cat data.dat | awk &amp;#39;{print $0}&amp;#39; for &amp;hellip; in &amp;hellip; for var in content 表示变量 var 在 content 中循环取</description>
    </item>
    
    <item>
      <title>Shell 使用模板文件生成文件</title>
      <link>https://csyakamoz.github.io/post/shell-build-file-from-template/</link>
      <pubDate>Wed, 09 Sep 2020 11:13:35 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/shell-build-file-from-template/</guid>
      <description>需求来源 有个模板文件，其占位符格式为：${variable} 现需要使用 shell 脚本来动态生成对应文件 实现 假设模板文件内容如下： #!/usr/bin/env bash version=&amp;#34;${version}&amp;#34; path=&amp;#34;${path}&amp;#34; 则动态生成对</description>
    </item>
    
    <item>
      <title>Shell 打印彩色输出</title>
      <link>https://csyakamoz.github.io/post/shell-print-color-output/</link>
      <pubDate>Wed, 09 Sep 2020 11:12:07 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/shell-print-color-output/</guid>
      <description>格式说明 ESC[{attr1};...;{attrN}m ESC: 转义字符，可选项为 \033, \x1b, \e 表示 m: 母鸡 attr: 控制代码（参见下方表格） 样例 简单的 echo -e &amp;#34;\033[0;31mRed\033[0m&amp;#34; echo -e &amp;#34;\033[0;32mGreen\033[0m&amp;#34; echo -e &amp;#34;\033[1;31mHighlight Red\033[0m&amp;#34; echo -e &amp;#34;\033[1;3;31mHighlight Italic Red\033[0m&amp;#34; echo -e &amp;#34;\033[1;3;4;31mHighlight Italic Underline Red\033[0m&amp;#34; 完整的 # https://askubuntu.com/questions/27314/script-to-display-all-terminal-colors for x in</description>
    </item>
    
    <item>
      <title>Shell 常用快捷键</title>
      <link>https://csyakamoz.github.io/post/shell-keyboard-shortcut/</link>
      <pubDate>Wed, 09 Sep 2020 11:06:40 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/shell-keyboard-shortcut/</guid>
      <description>Up, Ctrl + p, 显示上一条命令 Down, Ctrl + n, 显示下一条命令 Left, Ctrl + b, 光标向左移动一个字符 Right, Ctrl + f, 光标向右移动一个字符 BS, Ctrl + h, 删除光标左边的字符 Del, Ctrl + d, 删除光</description>
    </item>
    
    <item>
      <title>Node.js 创建本地模块</title>
      <link>https://csyakamoz.github.io/post/nodejs-crate-local-package/</link>
      <pubDate>Wed, 09 Sep 2020 11:00:07 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/nodejs-crate-local-package/</guid>
      <description>问题来源 在编写代码时，个人习惯会把通用实用模块放在项目根目录下 因为是通用实用模块，若项目层级较多，那么层级较深的文件引用该模块时，会出现这样</description>
    </item>
    
    <item>
      <title>Javascript 函数传参类型</title>
      <link>https://csyakamoz.github.io/post/javascript-function-parameter-type/</link>
      <pubDate>Wed, 09 Sep 2020 10:54:59 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/javascript-function-parameter-type/</guid>
      <description>曾经我一度将 javascript 函数传参类型分为两种： 基本类型：值传递 引用类型：引用传递 后来我发现，其实都是值传递; 先说明为啥曾经认为引用类型，是引用传递： function</description>
    </item>
    
    <item>
      <title>JavaScript 遍历对象属性顺序</title>
      <link>https://csyakamoz.github.io/post/javascript-iterate-object-property-order/</link>
      <pubDate>Wed, 09 Sep 2020 10:37:51 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/javascript-iterate-object-property-order/</guid>
      <description>问题来源 /** * @param {object} obj * @returns {any[]} */ function getValues(obj) { // some code or none return Object.values(obj); } const [val0, val1, ..., valN] = getValues(obj); doSomethingFor0(val0); doSomethingFor1(val1); ... doSomethingForN(valN); getValues 函数参数是对象，返回值是数组 调用者传入对象，再对函数返回的数组，进行</description>
    </item>
    
    <item>
      <title>编码风格</title>
      <link>https://csyakamoz.github.io/post/coding-style/</link>
      <pubDate>Wed, 09 Sep 2020 10:32:18 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/coding-style/</guid>
      <description>ESLint ESLint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code, with the goal of making code more consistent and avoiding bugs. 以下风格都会尽量补充对应的 eslint 规则（如果有且被我发现的话 😑 Notice: 请优先以团队约定为准!!! 缩进</description>
    </item>
    
    <item>
      <title>Node.js 调用微信小程序图片校验接口</title>
      <link>https://csyakamoz.github.io/post/nodejs-call-wechat-img-sec-check-api/</link>
      <pubDate>Wed, 09 Sep 2020 10:21:33 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/nodejs-call-wechat-img-sec-check-api/</guid>
      <description>const fs = require(&amp;#34;fs&amp;#34;); const request = require(&amp;#34;request&amp;#34;); request.post( { uri: &amp;#34;https://api.weixin.qq.com/wxa/img_sec_check?access_token=ACCESS_TOKEN&amp;#34;, formData: { // 方法 1 media: fs.createReadStream(&amp;#34;path_to_img&amp;#34;), // 方法 2 attachments: [ // 只认下标为 0 的 fs.createReadStream(&amp;#34;path_to_img&amp;#34;), // 下标 1 及之后的会被微信忽略 ..., ], // 方法 3 media: { value: buffer, options: { // 必须有 filename, 值可任意</description>
    </item>
    
    <item>
      <title>Node.js 支持的编码</title>
      <link>https://csyakamoz.github.io/post/nodejs-supported-encoding/</link>
      <pubDate>Wed, 09 Sep 2020 10:19:07 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/nodejs-supported-encoding/</guid>
      <description>ascii utf8 utf16le ucs2: alias of utf16le base64 latin1 binary: alias for latin1 hex 参考 List of encodings that Node.js supports Buffers and Character Encodings</description>
    </item>
    
  </channel>
</rss>